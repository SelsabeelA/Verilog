module multiplexer_4to1 (
  input wire I0, I1, I2, I3,   // 1-bit data inputs
  input wire S0, S1,          // 2-bit select input
  output wire Y               // Output result
);

  wire w0, w1, w2, w3;

  // AND gates to generate product terms
  assign w0 = I0 & ~S1 & ~S0;
  assign w1 = I1 & ~S1 & S0;
  assign w2 = I2 & S1 & ~S0;
  assign w3 = I3 & S1 & S0;

  // OR gate to combine product terms
  assign Y = w0 | w1 | w2 | w3;

endmodule

module full_adder (
  input wire A, B, Cin,  //1-bit data inputs
  output wire Sum, Cout  //Output result
);

  wire X1, X2, X3, X4, X5;

  // XOR gates for the sum bits
  assign X1 = A ^ B;
  assign Sum = X1 ^ Cin;

  // AND gates for the carry bits
  assign X2 = A & B;
  assign X3 = X1 & Cin;
  assign X4 = A & Cin;
  assign X5 = B & Cin;

  // OR gate to combine carry bits
  assign Cout = X2 | X3 | X4 | X5;

endmodule

module main;
  reg b0, b1, b2, a0, a1, a2;  // 1-bit values
  reg S0, S1;
  wire Y1, Y2, Y3, Y4, Y5, Y6;
  wire XOR1, XOR2, XOR3;
  wire sum1, cout1, sum2, cout2, sum3, cout3;

  multiplexer_4to1 first (
    a0,   // I0
    a0,   // I1
    a0,   // I2
    b0,   // I3
    S0,   // S0
    S1,   // S1
    Y1     // Output Y
  );

  multiplexer_4to1 second (
    1'b1,   // I0
    b0,   // I1
    b0,   // I2
    1'b1,   // I3
    S0,   // S0
    S1,   // S1
    Y2     // Output Y
  );

  multiplexer_4to1 third (
    a1,   // I0
    a1,   // I1
    a1,   // I2
    b1,   // I3
    S0,   // S0
    S1,   // S1
    Y3     // Output Y
  );

  multiplexer_4to1 fourth (
    1'b0,   // I0
    b1,   // I1
    b1,   // I2
    1'b0,   // I3
    S0,   // S0
    S1,   // S1
    Y4     // Output Y
  );

  multiplexer_4to1 fifth (
    a2,   // I0
    a2,   // I1
    a2,   // I2
    b2,   // I3
    S0,   // S0
    S1,   // S1
    Y5     // Output Y
  );

  multiplexer_4to1 sixth (
    1'b0,   // I0
    b2,   // I1
    b2,   // I2
    1'b0,   // I3
    S0,   // S0
    S1,   // S1
    Y6     // Output Y
  );

// XOR gates (XORing with S0 to get the complement values in the last 2 cases only where S0 = 1)
  assign XOR1 = S0 ^ Y1;
  assign XOR2 = S0 ^ Y3;
  assign XOR3 = S0 ^ Y5;

// Full adders
  full_adder fa1 (
    .A(XOR1),   //A0
    .B(Y2),     //B0
    .Cin(S0),   //Cin0
    .Sum(sum1), //Sum0
    .Cout(cout1)  //Cout0
  );

  full_adder fa2 (
    .A(XOR2),   //A1
    .B(Y4),     //B1
    .Cin(cout1),  //Cin1
    .Sum(sum2),     //Sum1
    .Cout(cout2)    //Cout1
    );
  
  full_adder fa3 (
    .A(XOR3),   //A2
    .B(Y6),     //B2
    .Cin(cout2),  //Cin2
    .Sum(sum3),    //Sum2 
    .Cout(cout3)    //Cout2
  );
  
  initial begin
  $monitor($time, " a=%b%b%b, b=%b%b%b, S=%b%b, G=%b%b%b",
    a2, a1, a0, b2, b1, b0, S1, S0, sum3, sum2, sum1
  );

  #0  a0=0; a1=1; a2=0; b0=1; b1=1; b2=0; S0=0; S1=0;  //A = 2, B = 3
  #10 a0=0; a1=1; a2=0; b0=1; b1=1; b2=0; S0=0; S1=1;  //A = 2, B = 3
  #20 a0=0; a1=1; a2=0; b0=1; b1=1; b2=0; S0=1; S1=0;  //A = 2, B = 3
  #30 a0=0; a1=1; a2=0; b0=1; b1=1; b2=0; S0=1; S1=1;  //A = 2, B = 3

  #40 a0=0; a1=1; a2=0; b0=1; b1=1; b2=0; S0=0; S1=0;  //A+1: A[+ve]
  #50 a0=1; a1=1; a2=1; b0=1; b1=1; b2=0; S0=0; S1=0;  //A+1: A[-ve]

  #60 a0=0; a1=1; a2=0; b0=1; b1=0; b2=0; S0=0; S1=1;  //A+B: A[+ve], B[+ve]
  #70 a0=1; a1=1; a2=0; b0=0; b1=1; b2=1; S0=0; S1=1;  //A+B: A[+ve], B[-ve]
  #80 a0=1; a1=0; a2=1; b0=1; b1=0; b2=0; S0=0; S1=1;  //A+B: A[-ve], B[+ve]
  #90 a0=1; a1=0; a2=1; b0=1; b1=1; b2=1; S0=0; S1=1;  //A+B: A[-ve], B[-ve]

  #100 a0=0; a1=1; a2=0; b0=1; b1=1; b2=0; S0=1; S1=0; //B-A: B[+ve], A[+ve]
  #110 a0=1; a1=1; a2=1; b0=0; b1=1; b2=0; S0=1; S1=0; //B-A: B[+ve], A[-ve]
  #120 a0=1; a1=0; a2=0; b0=1; b1=1; b2=1; S0=1; S1=0; //B-A: B[-ve], A[+ve]
  #130 a0=0; a1=1; a2=1; b0=0; b1=1; b2=1; S0=1; S1=0; //B-A: B[-ve], A[-ve]

  #140 a0=0; a1=0; a2=0; b0=0; b1=1; b2=0; S0=1; S1=1; //1-B: B[+ve]
  #150 a0=0; a1=0; a2=0; b0=1; b1=1; b2=1; S0=1; S1=1; //1-B: B[-ve]
  #160 a0=0; a1=0; a2=0; b0=0; b1=1; b2=1; S0=1; S1=1; //1-B: B[-ve]
  #160 a0=0; a1=0; a2=0; b0=1; b1=0; b2=1; S0=1; S1=1; //1-B: B[-ve]
  #160 a0=0; a1=0; a2=0; b0=0; b1=0; b2=0; S0=1; S1=1; //1-B: B[ZERO]

  #160 $finish; // Add a finish statement to end the simulation
  end

endmodule
