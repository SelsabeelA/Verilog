module multiplexer_4to1 (
  input wire I0, I1, I2, I3,   // 1-bit data inputs
  input wire S0, S1,          // 2-bit select input
  output wire Y               // Output result
);

  wire w0, w1, w2, w3;

  // AND gates to generate product terms
  assign w0 = I0 & ~S1 & ~S0;
  assign w1 = I1 & ~S1 & S0;
  assign w2 = I2 & S1 & ~S0;
  assign w3 = I3 & S1 & S0;

  // OR gate to combine product terms
  assign Y = w0 | w1 | w2 | w3;

endmodule

module full_adder (
  input wire A, B, Cin,  //1-bit data inputs
  output wire Sum, Cout  //Output result
);

  wire X1, X2, X3, X4, X5;

  // XOR gates for the sum bits
  assign X1 = A ^ B;
  assign Sum = X1 ^ Cin;

  // AND gates for the carry bits
  assign X2 = A & B;
  assign X3 = X1 & Cin;
  assign X4 = A & Cin;
  assign X5 = B & Cin;

  // OR gate to combine carry bits
  assign Cout = X2 | X3 | X4 | X5;

endmodule

module main;
  reg [2:0] a;  // 3-bit binary numbers
  reg [2:0] b;  // 3-bit binary numbers
  reg S0,S1;         // 2-bit binary number
  wire Y1, Y2, Y3, Y4, Y5, Y6;
  wire XOR1, XOR2, XOR3;
  wire sum1, cout1, sum2, cout2, sum3, cout3;

  multiplexer_4to1 first (
    a[0],  // I0
    a[0],  // I1
    a[0],  // I2
    b[0],  // I3
    S0,  // S0
    S1,  // S1
    Y1     // Output Y
  );

  multiplexer_4to1 second (
    1'b1,  // I0
    b[0],  // I1
    b[0],  // I2
    1'b1,  // I3
    S0,  // S0
    S1,  // S1
    Y2     // Output Y
  );

  multiplexer_4to1 third (
    a[1],  // I0
    a[1],  // I1
    a[1],  // I2
    b[1],  // I3
    S0,  // S0
    S1,  // S1
    Y3     // Output Y
  );

  multiplexer_4to1 fourth (
    1'b0,  // I0
    b[1],  // I1
    b[1],  // I2
    1'b0,  // I3
    S0,  // S0
    S1,  // S1
    Y4     // Output Y
  );

  multiplexer_4to1 fifth (
    a[2],  // I0
    a[2],  // I1
    a[2],  // I2
    b[2],  // I3
    S0,  // S0
    S1,  // S1
    Y5     // Output Y
  );

  multiplexer_4to1 sixth (
    1'b0,  // I0
    b[2],  // I1
    b[2],  // I2
    1'b0,  // I3
    S0,  // S0
    S1,  // S1
    Y6     // Output Y
  );

  // XOR gates (XORing with S0 to get the complement values in the last 2 cases only where S0 = 1)
  assign XOR1 = S1 ^ Y1;
  assign XOR2 = S1 ^ Y3;
  assign XOR3 = S1 ^ Y5;

  // Full adders
  full_adder fa1 (
    .A(XOR1),   // A0
    .B(Y2),     // B0
    .Cin(S1),  // Cin0
    .Sum(sum1), // Sum0
    .Cout(cout1)  // Cout0
  );

  full_adder fa2 (
    .A(XOR2),   // A1
    .B(Y4),     // B1
    .Cin(cout1),  // Cin1
    .Sum(sum2),     // Sum1
    .Cout(cout2)    // Cout1
  );
  
  full_adder fa3 (
    .A(XOR3),   // A2
    .B(Y6),     // B2
    .Cin(cout2),  // Cin2
    .Sum(sum3),    // Sum2 
    .Cout(cout3)    // Cout2
  );
//  S=00, G=A+1 ; S=01, G=A+B, S=10, G=B-A;S=11,G=1-B
  initial
    begin
      $monitor($time, " a=%b%b%b, b=%b%b%b, S=%b%b, G=%b%b%B", a[2], a[1], a[0], b[2], b[1], b[0], S1, S0,cout1,cout2, cout3);
      #0  a=3'b000; b=3'b000; S1=0;S0=0; // Y=001
      #10  a=3'b000; b=3'b000; S1=0;S0=1; // Y=000
      #10  a=3'b000; b=3'b000; S1=1;S0=0; // Y=000
      #10  a=3'b000; b=3'b000; S1=1;S0=1; // 000-001 = ?
      #10  a=3'b001; b=3'b000; S1=0;S0=0; // Y=010
      #10  a=3'b001; b=3'b000; S1=0;S0=1; // Y=001
      #10  a=3'b001; b=3'b000; S=2'b10;
      #10  a=3'b001; b=3'b000; S=2'b11;
      #10  a=3'b010; b=3'b000; S=2'b00;
      #10  a=3'b010; b=3'b000; S=2'b01;
      #10  a=3'b010; b=3'b000; S=2'b10;
      #10  a=3'b010; b=3'b000; S=2'b11;
      #10  a=3'b011; b=3'b000; S=2'b00;
      #10  a=3'b011; b=3'b000; S=2'b01;
      #10  a=3'b011; b=3'b000; S=2'b10;
      #10  a=3'b011; b=3'b000; S=2'b11;
      #10  a=3'b100; b=3'b000; S=2'b00;
      #10  a=3'b100; b=3'b000; S=2'b01;
      #10  a=3'b100; b=3'b000; S=2'b10;
      #10  a=3'b100; b=3'b000; S=2'b11;
      #10  a=3'b101; b=3'b000; S=2'b00;
      #10  a=3'b101; b=3'b000; S=2'b01;
      #10  a=3'b101; b=3'b000; S=2'b10;
      #10  a=3'b101; b=3'b000; S=2'b11;
      #10  a=3'b011; b=3'b000; S=2'b00;
      #10  a=3'b011; b=3'b000; S=2'b01;
      #10  a=3'b011; b=3'b000; S=2'b10;
      #10  a=3'b011; b=3'b000; S=2'b11;
      #10  a=3'b111; b=3'b000; S=2'b00;
      #10  a=3'b111; b=3'b000; S=2'b01;
      #10  a=3'b111; b=3'b000; S=2'b10;
      #10  a=3'b111; b=3'b000; S=2'b11;
      #10  a=3'b000; b=3'b001; S=2'b00;
      #10  a=3'b000; b=3'b001; S=2'b01;
      #10  a=3'b000; b=3'b001; S=2'b10;
      #10  a=3'b000; b=3'b001; S=2'b11;
      #10  a=3'b001; b=3'b001; S=2'b00;
      #10  a=3'b001; b=3'b001; S=2'b01;
      #10  a=3'b001; b=3'b001; S=2'b10;
      #10  a=3'b001; b=3'b001; S=2'b11;
    end
endmodule
